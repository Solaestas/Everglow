using Everglow.Commons.DataStructures;
using Everglow.Commons.MEAC;
using Everglow.Commons.Utilities;
using Everglow.Commons.Vertex;
using Everglow.Commons.VFX;

namespace Everglow.Commons.Templates.Weapons;

/// <summary>
/// Prodvide a trailling projectile template, Functions below can be modified for special trailing visual effects.<br></br>
/// · DrawTrail, the most common painting function for trail, called in PreDraw.<br></br>
/// · DrawSelf, draw projectile eneity, called after DrawTrailDark in DrawTrail.
/// </summary>
public abstract class TrailingProjectile : ModProjectile, IWarpProjectile_warpStyle2
{
	public override void SetDefaults()
	{
		Projectile.width = 32;
		Projectile.height = 32;
		Projectile.aiStyle = -1;
		Projectile.timeLeft = 360000;
		Projectile.tileCollide = true;
		Projectile.ignoreWater = true;
		Projectile.friendly = true;
		Projectile.penetrate = -1;
		TrailColor = new Color(1, 1, 1, 0f);
		TrailWidth = 30f;
		SelfLuminous = false;
		TrailTexture = ModAsset.Trail.Value;
		TrailTextureBlack = ModAsset.Trail_black.Value;
		TrailShader = ModAsset.Trailing.Value;
		SetCustomDefaults();
	}

	/// <summary>
	/// Default value can be modified here.
	/// <br></br>
	/// width = height = 32;<br></br>
	/// aistyle = -1;<br></br>
	/// timeLeft = 360000;<br></br>
	/// tileCollide = true;<br></br>
	/// ignoreWater = true;<br></br>
	/// friendly = true;<br></br>
	/// penetrate = -1;<br></br><br></br>
	/// TrailColor = new Color(1, 1, 1, 0f);<br></br>
	/// TrailWidth = 30f;<br></br>
	/// SelfLuminous = false;<br></br>
	/// TrailTexture = ModAsset.Trail.Value;<br></br>
	/// TrailTextureBlack = ModAsset.Trail_black.Value;<br></br>
	/// TrailShader = ModAsset.Trailing.Value;<br></br>
	/// </summary>
	public virtual void SetCustomDefaults()
	{
	}

	/// <summary>
	/// Prevent projectile being really killed after entity destroyed.<br></br>
	/// Negative before projectile entity destroyed(maybe hit tile or enemies...), positive after.Substrate 1 by every tick.<br></br>
	/// This field should NOT be modified manually.
	/// </summary>
	public int TimeAfterEntityDestroy = -1;

	/// <summary>
	/// Update every tick, add by 1.
	/// </summary>
	public int Timer = 0;

	/// <summary>
	/// Trail will only record the last [this value] tick of Projectile.Center.
	/// </summary>
	public int TrailLength = 20;

	/// <summary>
	/// The color of trail.
	/// </summary>
	public Color TrailColor;

	/// <summary>
	/// If false, the trail will influenced by environment light(TrailColor mixed with environment light).
	/// </summary>
	public bool SelfLuminous;

	/// <summary>
	/// The width of trailing track.<br></br>16 equal to a side of a tile.
	/// </summary>
	public float TrailWidth;

	/// <summary>
	/// The value of warp strength.
	/// </summary>
	public float WarpStrength = 1f;

	/// <summary>
	/// 0~1, 0f will cancel the trail background (so the trail may be a bit shallow), 1f will draw the whole dark trail background.
	/// A porper value can make the trail more vividly.
	/// </summary>
	public float TrailBackgroundDarkness = 1f;

	/// <summary>
	/// Texture of trail.
	/// </summary>
	public Texture2D TrailTexture;

	/// <summary>
	/// Texture of a traili, usually convert the TrailTexture(RGBA)→(000R).
	/// </summary>
	public Texture2D TrailTextureBlack;

	/// <summary>
	/// The shader use to trail, parameter "uTransform" should be contained.
	/// </summary>
	public Effect TrailShader;

	/// <summary>
	/// Record old projectile position(Projectile.Center).
	/// </summary>
	public Queue<Vector2> TrailPos = new Queue<Vector2>();

	/// <summary>
	/// New curve generated by smoothing projectile.OldPos[], notice that it length different from projectile.OldPos.Length in most cases.
	/// </summary>
	public List<Vector2> SmoothedOldPos = new List<Vector2>();

	/// <summary>
	/// Override Behaviors() instead of AI().<br></br>
	/// If you still want to override AI(), notice that base.AI(); should NOT be removed EXCEPT for you are familiar with the logic.
	/// </summary>
	public override void AI()
	{
		Timer++;
		TrailPos.Enqueue(Projectile.Center);
		if (TrailPos.Count > TrailLength)
		{
			TrailPos.Dequeue();
		}
		Behaviors();
		SmoothTrail();
		TimeAfterEntityDestroy--;
		if (TimeAfterEntityDestroy >= 0 && TimeAfterEntityDestroy <= 2)
		{
			Projectile.Kill();
		}
		if (TimeAfterEntityDestroy >= 0)
		{
			Projectile.velocity *= 0f;
			return;
		}
	}

	/// <summary>
	/// The running logic of this projectile.
	/// </summary>
	public virtual void Behaviors()
	{
	}

	/// <summary>
	/// Use catmullRom method. Override this can modify the curve function, such as bezier.
	/// </summary>
	public virtual void SmoothTrail()
	{
		SmoothedOldPos.Clear();
		var unSmoothPos = TrailPos.ToList();
		unSmoothPos.Reverse();
		List<Vector2> smoothTrail = GraphicsUtils.CatmullRom(unSmoothPos);
		SmoothedOldPos.AddRange(smoothTrail);
	}

	public override void OnHitNPC(NPC target, NPC.HitInfo hit, int damageDone)
	{
		DestroyEntity();
	}

	public override void OnHitPlayer(Player target, Player.HurtInfo info)
	{
		DestroyEntity();
	}

	public override bool OnTileCollide(Vector2 oldVelocity)
	{
		DestroyEntity();
		Projectile.tileCollide = false;
		return false;
	}

	/// <summary>
	/// Try to override DestroyEntityEffect instead of this.<br></br>
	/// Destroy the entity of projectile(visually killed).But the rest of trail will be maintain for TrailLength ticks to dissolve gradually.<br></br>
	/// After DestroyEntity, projectile will not hit to anything.
	/// </summary>
	public virtual void DestroyEntity()
	{
		Projectile.velocity = Projectile.oldVelocity;
		Projectile.friendly = false;
		if (TimeAfterEntityDestroy < 0)
		{
			DestroyEntityEffect();
		}
		TimeAfterEntityDestroy = TrailLength;
	}

	/// <summary>
	/// Visual effect when entity destroying.
	/// </summary>
	public virtual void DestroyEntityEffect()
	{
	}

	/// <summary>
	/// Called in PreDraw().Use primitive draw and shader to render a trail.
	/// </summary>
	public virtual void DrawTrail()
	{
		SpriteBatchState sBS = Main.spriteBatch.GetState().Value;
		Main.spriteBatch.End();
		Main.spriteBatch.Begin(SpriteSortMode.Immediate, BlendState.AlphaBlend, SamplerState.PointWrap, DepthStencilState.None, RasterizerState.CullNone, null, Main.GameViewMatrix.TransformationMatrix);
		Effect effect = TrailShader;
		var projection = Matrix.CreateOrthographicOffCenter(0, Main.screenWidth, Main.screenHeight, 0, 0, 1);
		var model = Matrix.CreateTranslation(new Vector3(-Main.screenPosition, 0)) * Main.GameViewMatrix.TransformationMatrix;
		effect.Parameters["uTransform"].SetValue(model * projection);
		effect.CurrentTechnique.Passes[0].Apply();

		// Draw black background first.
		Main.graphics.GraphicsDevice.Textures[0] = TrailTextureBlack;
		var bars0 = new List<Vertex2D>();
		var bars1 = new List<Vertex2D>();
		var bars2 = new List<Vertex2D>();

		int countSafe = 0;
		float darknessRemainder = TrailBackgroundDarkness;
		while (darknessRemainder > 0)
		{
			float darkValue = 1;
			if (darknessRemainder < 1f)
			{
				darkValue = darknessRemainder;
			}
			CreateTrailVertex(bars0, bars1, bars2, 0, default, darkValue);
			if (bars0.Count >= 2 && bars1.Count >= 2 && bars2.Count >= 2)
			{
				Main.graphics.GraphicsDevice.DrawUserPrimitives(PrimitiveType.TriangleStrip, bars0.ToArray(), 0, bars0.Count - 2);
				Main.graphics.GraphicsDevice.DrawUserPrimitives(PrimitiveType.TriangleStrip, bars1.ToArray(), 0, bars1.Count - 2);
				Main.graphics.GraphicsDevice.DrawUserPrimitives(PrimitiveType.TriangleStrip, bars2.ToArray(), 0, bars2.Count - 2);
			}
			darknessRemainder -= 1f;
			countSafe++;
			if (countSafe > 100)
			{
				break;
			}
		}

		// Then, draw the colorful trail.
		Main.graphics.GraphicsDevice.Textures[0] = TrailTexture;
		bars0.Clear();
		bars1.Clear();
		bars2.Clear();
		CreateTrailVertex(bars0, bars1, bars2, 1);
		if (bars0.Count >= 2 && bars1.Count >= 2 && bars2.Count >= 2)
		{
			Main.graphics.GraphicsDevice.DrawUserPrimitives(PrimitiveType.TriangleStrip, bars0.ToArray(), 0, bars0.Count - 2);
			Main.graphics.GraphicsDevice.DrawUserPrimitives(PrimitiveType.TriangleStrip, bars1.ToArray(), 0, bars1.Count - 2);
			Main.graphics.GraphicsDevice.DrawUserPrimitives(PrimitiveType.TriangleStrip, bars2.ToArray(), 0, bars2.Count - 2);
		}
		Main.spriteBatch.End();
		Main.spriteBatch.Begin(sBS);
	}

	/// <summary>
	/// You can override it to modify the trail.
	/// style == 0: Black background<br></br>
	/// style == 1: Normal<br></br>
	/// style == 2: Warp<br></br>
	/// style >= 3: Custom
	/// </summary>
	/// <param name="bars0"></param>
	/// <param name="bars1"></param>
	/// <param name="bars2"></param>
	/// <param name="style"></param>
	public virtual void CreateTrailVertex(List<Vertex2D> bars0, List<Vertex2D> bars1, List<Vertex2D> bars2, int style, Vector2 offset = default, float extraValue0 = 0, float extraValue1 = 0)
	{
		// If there is no any element here, return.
		if (SmoothedOldPos.Count <= 0 || TrailLength <= 0)
		{
			return;
		}

		// If dark, the Color.White will be proper.
		for (int i = -1; i < SmoothedOldPos.Count; ++i)
		{
			// factor, among 0 to 1, usually for deciding the trail's texture.coord.X.
			float mulFac = Timer / (float)TrailLength;
			if (mulFac > 1f)
			{
				mulFac = 1f;
			}
			float factor = (i + 1) / (float)SmoothedOldPos.Count * mulFac;

			float width = 0;
			if (i >= 0)
			{
				width = TrailWidthFunction(factor);
			}

			// timeValue, animate the trail.
			float timeValue = Timer * 0.05f;
			Vector2 drawPos = Projectile.Center;
			if (i >= 0)
			{
				drawPos = SmoothedOldPos[i];
			}
			Color drawColor = GetTrailColor(style, drawPos, i, ref factor, extraValue0, extraValue1);
			drawPos += offset;
			bars0.Add(drawPos + new Vector2(0, 1).RotatedBy(MathHelper.TwoPi * 2f / 3f) * TrailWidth, drawColor, ModifyTrailTextureCoordinate(factor, timeValue, 0, width));
			bars0.Add(drawPos, drawColor, ModifyTrailTextureCoordinate(factor, timeValue, 1, width));
			bars1.Add(drawPos + new Vector2(0, 1).RotatedBy(MathHelper.TwoPi * 1f / 3f) * TrailWidth, drawColor, ModifyTrailTextureCoordinate(factor, timeValue, 2, width));
			bars1.Add(drawPos, drawColor, ModifyTrailTextureCoordinate(factor, timeValue, 3, width));
			bars2.Add(drawPos + new Vector2(0, 1).RotatedBy(MathHelper.TwoPi * 0f / 3f) * TrailWidth, drawColor, ModifyTrailTextureCoordinate(factor, timeValue, 4, width));
			bars2.Add(drawPos, drawColor, ModifyTrailTextureCoordinate(factor, timeValue, 5, width));
		}
	}

	/// <summary>
	/// Get the color while adding trailing primitives.Allow adding custon logics for trail color.<br></br>
	/// style == 0: Black background<br></br>
	/// style == 1: Normal<br></br>
	/// style == 2: Warp
	/// <br></br>
	/// style >= 3: Custom
	/// </summary>
	/// <param name="style"></param>
	/// <param name="worldPos"></param>
	/// <param name="index"></param>
	/// <param name="factor"></param>
	/// <returns></returns>
	public virtual Color GetTrailColor(int style, Vector2 worldPos, int index, ref float factor, float extraValue0 = 0, float extraValue1 = 0)
	{
		Color drawColor = Color.White;
		if (style == 0)
		{
			drawColor *= extraValue0;
		}
		if (style == 1)
		{
			drawColor = TrailColor;
			if (!SelfLuminous)
			{
				Color lightC = Lighting.GetColor(worldPos.ToTileCoordinates());
				drawColor.R = (byte)(lightC.R * drawColor.R / 255f);
				drawColor.G = (byte)(lightC.G * drawColor.G / 255f);
				drawColor.B = (byte)(lightC.B * drawColor.B / 255f);
			}
		}
		if (style == 2)
		{
			var normalDir = Projectile.velocity;
			if (index >= 1)
			{
				normalDir = SmoothedOldPos[index - 1] - SmoothedOldPos[index];
			}
			normalDir = normalDir.NormalizeSafe();
			drawColor = new Color(1 - (normalDir.X + 25f) / 50f, 1 - (normalDir.Y + 25f) / 50f, WarpStrength, 1);
		}
		return drawColor;
	}

	/// <summary>
	/// Allow you modify the trailing coords.<br></br>
	/// phase:0,1→bars0;<br></br>
	/// phase:2,3→bars1;<br></br>
	/// phase:4,5→bars2;<br></br>
	/// timeValue default to Tiemr * 0.05f
	/// </summary>
	/// <param name="factor"></param>
	/// <param name="timeValue"></param>
	/// <param name="phase"></param>
	/// <param name="widthValue"></param>
	/// <returns></returns>
	public virtual Vector3 ModifyTrailTextureCoordinate(float factor, float timeValue, float phase, float widthValue)
	{
		float x = factor + timeValue;
		float y = 1;
		float z = widthValue;
		if (phase == 2)
		{
			y = 0;
		}
		if (phase % 2 == 1)
		{
			y = 0.5f;
		}
		return new Vector3(x, y, z);
	}

	/// <summary>
	/// To make the trail more smooth, we convey this 0~1 parameter to shader.
	/// </summary>
	/// <returns></returns>
	public virtual float TrailWidthFunction(float factor)
	{
		if (factor < 0)
		{
			return 0;
		}
		factor = MathF.Pow(factor, 0.5f);
		return MathF.Sin(factor * MathHelper.Pi);
	}

	public override bool PreDraw(ref Color lightColor)
	{
		DrawTrail();
		if (TimeAfterEntityDestroy <= 0)
		{
			DrawSelf();
		}
		return false;
	}

	public virtual void DrawSelf()
	{
		var texMain = (Texture2D)ModContent.Request<Texture2D>(Texture);
		Color color = TrailColor;
		if (!SelfLuminous)
		{
			color = Lighting.GetColor(Projectile.Center.ToTileCoordinates());
		}
		Main.spriteBatch.Draw(texMain, Projectile.Center - Main.screenPosition, null, color, Projectile.rotation, texMain.Size() / 2f, 1f, SpriteEffects.None, 0);
	}

	public virtual void DrawWarp(VFXBatch spriteBatch)
	{
		if (SmoothedOldPos.Count <= 0)
		{
			return;
		}
		var bars0 = new List<Vertex2D>();
		var bars1 = new List<Vertex2D>();
		var bars2 = new List<Vertex2D>();
		CreateTrailVertex(bars0, bars1, bars2, 2, -Main.screenPosition);
		if (bars0.Count >= 2 && bars1.Count >= 2 && bars2.Count >= 3)
		{
			spriteBatch.Draw(TrailTexture, bars0, PrimitiveType.TriangleStrip);
			spriteBatch.Draw(TrailTexture, bars1, PrimitiveType.TriangleStrip);
			spriteBatch.Draw(TrailTexture, bars2, PrimitiveType.TriangleStrip);
		}
	}
}