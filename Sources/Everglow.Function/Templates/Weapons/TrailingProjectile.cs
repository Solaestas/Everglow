using Everglow.Commons.DataStructures;
using Everglow.Commons.MEAC;
using Everglow.Commons.Utilities;
using Everglow.Commons.Vertex;
using Everglow.Commons.VFX;

namespace Everglow.Commons.Templates.Weapons;

/// <summary>
/// Prodvide a trailling projectile template, Functions below can be modified for special trailing visual effects.<br></br>
/// · DrawTrailDark, usually paint as a black background called before DrawTrail in PreDraw.<br></br>
/// · DrawTrail, the most common painting function for trail, called after DrawTrailDark in PreDraw.<br></br>
/// · DrawSelf, draw projectile eneity, called after DrawTrailDark in DrawTrail.
/// </summary>
public abstract class TrailingProjectile : ModProjectile, IWarpProjectile_warpStyle2
{
	public override void SetDefaults()
	{
		Projectile.width = 32;
		Projectile.height = 32;
		Projectile.aiStyle = -1;
		Projectile.timeLeft = 360000;
		Projectile.tileCollide = true;
		Projectile.ignoreWater = true;
		Projectile.friendly = true;
		Projectile.penetrate = -1;
		TrailColor = new Color(1, 1, 1, 0f);
		TrailWidth = 30f;
		SelfLuminous = false;
		TrailTexture = ModAsset.Trail.Value;
		TrailTextureBlack = ModAsset.Trail_black.Value;
		TrailShader = ModAsset.Trailing.Value;
		SetDef();
	}

	/// <summary>
	/// Default value can be modified here.
	/// <br></br>
	/// width = height = 32;<br></br>
	/// aistyle = -1;<br></br>
	/// timeLeft = 360000;<br></br>
	/// tileCollide = true;<br></br>
	/// ignoreWater = true;<br></br>
	/// friendly = true;<br></br>
	/// penetrate = -1;<br></br><br></br>
	/// ProjectileID.Sets.TrailingMode[Projectile.type] = 0;<br></br>
	/// ProjectileID.Sets.TrailCacheLength[Projectile.type] = 90;<br></br><br></br>
	/// TrailColor = new Color(1, 1, 1, 0f);<br></br>
	/// TrailWidth = 30f;<br></br>
	/// SelfLuminous = false;<br></br>
	/// TrailTexture = ModAsset.Trail.Value;<br></br>
	/// TrailTextureBlack = ModAsset.Trail_black.Value;<br></br>
	/// TrailShader = ModAsset.Trailing.Value;<br></br>
	/// </summary>
	public virtual void SetDef()
	{
	}

	/// <summary>
	/// Prevent projectile being really killed after visually killed.<br></br>
	/// Negative before projectile visually killed(when projectile hit tile, hit enemies...), positive after.Substrate 1 by every tick.<br></br>
	/// This field should NOT be modified manually.
	/// </summary>
	public int TimeTokill = -1;

	/// <summary>
	/// Update every tick, add by 1.
	/// </summary>
	public int Timer = 0;

	/// <summary>
	/// Trail will only record the last [this value] tick of Projectile.Center.
	/// </summary>
	public int TrailLength = 20;

	/// <summary>
	/// The color of trail.
	/// </summary>
	public Color TrailColor;

	/// <summary>
	/// If false, the trail will influenced by environment light(TrailColor mixed with environment light).
	/// </summary>
	public bool SelfLuminous;

	/// <summary>
	/// The width of trailing track.<br></br>16 equal to a side of a tile.
	/// </summary>
	public float TrailWidth;

	/// <summary>
	/// The value of warp strength.
	/// </summary>
	public float WarpStrength = 1f;

	/// <summary>
	/// Texture of trail.
	/// </summary>
	public Texture2D TrailTexture;

	/// <summary>
	/// Texture of a traili, usually convert the TrailTexture(RGBA)→(000R).
	/// </summary>
	public Texture2D TrailTextureBlack;

	/// <summary>
	/// The shader use to trail, parameter "uTransform" should be contained.
	/// </summary>
	public Effect TrailShader;

	/// <summary>
	/// Record old projectile position(Projectile.Center).
	/// </summary>
	public Queue<Vector2> TrailPos = new Queue<Vector2>();

	/// <summary>
	/// New curve generated by smoothing projectile.OldPos[], notice that it length different from projectile.OldPos.Length in most cases.
	/// </summary>
	public List<Vector2> SmoothedOldPos = new List<Vector2>();

	/// <summary>
	/// Override Behaviors() instead of AI().<br></br>
	/// If you still want to override AI(), notice that base.AI(); should NOT be removed EXCEPT for you are familiar with the logic.
	/// </summary>
	public override void AI()
	{
		Timer++;
		TrailPos.Enqueue(Projectile.Center);
		if (TrailPos.Count > TrailLength)
		{
			TrailPos.Dequeue();
		}
		Behaviors();
		SmoothTrail();
		Projectile.rotation = MathF.Atan2(Projectile.velocity.Y, Projectile.velocity.X);

		TimeTokill--;
		if (TimeTokill >= 0 && TimeTokill <= 2)
		{
			Projectile.Kill();
		}
		if (TimeTokill >= 0)
		{
			Projectile.velocity *= 0f;
			return;
		}
	}

	/// <summary>
	/// The running logic of this projectile.
	/// </summary>
	public virtual void Behaviors()
	{
	}

	public void SmoothTrail()
	{
		SmoothedOldPos.Clear();
		var unSmoothPos = TrailPos.ToList();
		unSmoothPos.Reverse();
		List<Vector2> smoothTrail = GraphicsUtils.CatmullRom(unSmoothPos);
		SmoothedOldPos.AddRange(smoothTrail);
	}

	public override void OnHitNPC(NPC target, NPC.HitInfo hit, int damageDone)
	{
		KillMainStructure();
	}

	public override void OnHitPlayer(Player target, Player.HurtInfo info)
	{
		KillMainStructure();
	}

	public override bool OnTileCollide(Vector2 oldVelocity)
	{
		KillMainStructure();
		Projectile.tileCollide = false;
		return false;
	}

	public virtual void KillMainStructure()
	{
		Projectile.velocity = Projectile.oldVelocity;
		Projectile.friendly = false;
		if (TimeTokill < 0)
		{
			Explosion();
		}
		TimeTokill = ProjectileID.Sets.TrailCacheLength[Projectile.type];
	}

	public virtual void Explosion()
	{
	}

	/// <summary>
	/// Default to call this before DrawTrail.
	/// </summary>
	public virtual void DrawTrailDark()
	{
		// We should calculate OldCenter manually by plusing this to OldPos or SmoothedOldPos.
		var bars0 = new List<Vertex2D>();
		var bars1 = new List<Vertex2D>();
		var bars2 = new List<Vertex2D>();
		CreateTrailVertex(bars0, bars1, bars2, true);
		SpriteBatchState sBS = Main.spriteBatch.GetState().Value;
		Main.spriteBatch.End();
		Main.spriteBatch.Begin(SpriteSortMode.Deferred, BlendState.AlphaBlend, Main.DefaultSamplerState, DepthStencilState.None, RasterizerState.CullNone, null, Main.GameViewMatrix.TransformationMatrix);
		Effect effect = TrailShader;
		var projection = Matrix.CreateOrthographicOffCenter(0, Main.screenWidth, Main.screenHeight, 0, 0, 1);
		var model = Matrix.CreateTranslation(new Vector3(-Main.screenPosition.X, -Main.screenPosition.Y, 0)) * Main.GameViewMatrix.TransformationMatrix;
		effect.Parameters["uTransform"].SetValue(model * projection);
		effect.CurrentTechnique.Passes[0].Apply();
		Main.graphics.GraphicsDevice.Textures[0] = TrailTextureBlack;
		if (bars0.Count >= 2 && bars1.Count >= 2 && bars2.Count >= 2)
		{
			Main.graphics.GraphicsDevice.DrawUserPrimitives(PrimitiveType.TriangleStrip, bars0.ToArray(), 0, bars0.Count - 2);
			Main.graphics.GraphicsDevice.DrawUserPrimitives(PrimitiveType.TriangleStrip, bars1.ToArray(), 0, bars1.Count - 2);
			Main.graphics.GraphicsDevice.DrawUserPrimitives(PrimitiveType.TriangleStrip, bars2.ToArray(), 0, bars2.Count - 2);
		}
		Main.spriteBatch.End();
		Main.spriteBatch.Begin(sBS);
	}

	public virtual void DrawTrail()
	{
		var bars0 = new List<Vertex2D>();
		var bars1 = new List<Vertex2D>();
		var bars2 = new List<Vertex2D>();
		CreateTrailVertex(bars0, bars1, bars2, false);
		SpriteBatchState sBS = Main.spriteBatch.GetState().Value;
		Main.spriteBatch.End();
		Main.spriteBatch.Begin(SpriteSortMode.Immediate, BlendState.AlphaBlend, SamplerState.PointWrap, DepthStencilState.None, RasterizerState.CullNone, null, Main.GameViewMatrix.TransformationMatrix);
		Effect effect = TrailShader;
		var projection = Matrix.CreateOrthographicOffCenter(0, Main.screenWidth, Main.screenHeight, 0, 0, 1);
		var model = Matrix.CreateTranslation(new Vector3(-Main.screenPosition, 0)) * Main.GameViewMatrix.TransformationMatrix;
		effect.Parameters["uTransform"].SetValue(model * projection);
		effect.CurrentTechnique.Passes[0].Apply();
		Main.graphics.GraphicsDevice.Textures[0] = TrailTexture;
		if (bars0.Count >= 2 && bars1.Count >= 2 && bars2.Count >= 2)
		{
			Main.graphics.GraphicsDevice.DrawUserPrimitives(PrimitiveType.TriangleStrip, bars0.ToArray(), 0, bars0.Count - 2);
			Main.graphics.GraphicsDevice.DrawUserPrimitives(PrimitiveType.TriangleStrip, bars1.ToArray(), 0, bars1.Count - 2);
			Main.graphics.GraphicsDevice.DrawUserPrimitives(PrimitiveType.TriangleStrip, bars2.ToArray(), 0, bars2.Count - 2);
		}
		Main.spriteBatch.End();
		Main.spriteBatch.Begin(sBS);
	}

	public virtual void CreateTrailVertex(List<Vertex2D> bars0, List<Vertex2D> bars1, List<Vertex2D> bars2, bool dark)
	{
		// If there is no any element here, return.
		if (SmoothedOldPos.Count <= 0)
		{
			return;
		}
		Color drawColor = Color.White;
		for (int i = -1; i < SmoothedOldPos.Count; ++i)
		{
			float mulFac = Timer / (float)ProjectileID.Sets.TrailCacheLength[Projectile.type];
			if (mulFac > 1f)
			{
				mulFac = 1f;
			}
			float factor = (i + 1) / (float)SmoothedOldPos.Count * mulFac;
			float width = 0;
			if (i >= 0)
			{
				width = TrailWidthFunction(factor);
			}
			factor *= 7;
			float timeValue = (float)Main.time * 0.06f;
			Vector2 drawPos = Projectile.Center;
			if (i >= 0)
			{
				drawPos = SmoothedOldPos[i];
			}

			if(!dark)
			{
				drawColor = TrailColor;
				if (!SelfLuminous)
				{
					Color lightC = Lighting.GetColor((drawPos / 16f).ToPoint());
					drawColor.R = (byte)(lightC.R * drawColor.R / 255f);
					drawColor.G = (byte)(lightC.G * drawColor.G / 255f);
					drawColor.B = (byte)(lightC.B * drawColor.B / 255f);
				}
			}
			bars0.Add(drawPos + new Vector2(0, 1).RotatedBy(MathHelper.TwoPi * 2f / 3f) * TrailWidth, drawColor, new Vector3(factor + timeValue, 1, width));
			bars0.Add(drawPos, drawColor, new Vector3(factor + timeValue, 0.5f, width));
			bars1.Add(drawPos + new Vector2(0, 1).RotatedBy(MathHelper.TwoPi * 1f / 3f) * TrailWidth, drawColor, new Vector3(factor + timeValue, 0, width));
			bars1.Add(drawPos, drawColor, new Vector3(factor + timeValue, 0.5f, width));
			bars2.Add(drawPos + new Vector2(0, 1).RotatedBy(MathHelper.TwoPi * 0f / 3f) * TrailWidth, drawColor, new Vector3(factor + timeValue, 1, width));
			bars2.Add(drawPos, drawColor, new Vector3(factor + timeValue, 0.5f, width));
		}
	}

	/// <summary>
	/// To make the trail more smooth, we convey this 0~1 parameter to shader.
	/// </summary>
	/// <returns></returns>
	public virtual float TrailWidthFunction(float factor)
	{
		if (factor < 0)
		{
			return 0;
		}
		factor = MathF.Pow(factor, 0.5f);
		return MathF.Sin(factor * MathHelper.Pi);
	}

	public override bool PreDraw(ref Color lightColor)
	{
		DrawTrailDark();
		DrawTrail();
		if (TimeTokill <= 0)
		{
			DrawSelf();
		}
		return false;
	}

	public virtual void DrawSelf()
	{
		var texMain = (Texture2D)ModContent.Request<Texture2D>(Texture);
		Main.spriteBatch.Draw(texMain, Projectile.Center - Main.screenPosition, null, TrailColor, Projectile.rotation, texMain.Size() / 2f, 1f, SpriteEffects.None, 0);
	}

	public void DrawWarp(VFXBatch spriteBatch)
	{
		if (SmoothedOldPos.Count <= 0)
		{
			return;
		}
		Vector2 halfSize = new Vector2(Projectile.width, Projectile.height) / 2f;
		float width = TrailWidth;
		var bars = new List<Vertex2D>();
		var bars2 = new List<Vertex2D>();
		var bars3 = new List<Vertex2D>();
		for (int i = 1; i < SmoothedOldPos.Count; ++i)
		{
			if (SmoothedOldPos[i] == Vector2.Zero)
			{
				break;
			}
			var normalDir = SmoothedOldPos[i - 1] - SmoothedOldPos[i];
			float mulFac = Timer / (float)ProjectileID.Sets.TrailCacheLength[Projectile.type];
			if (mulFac > 1f)
			{
				mulFac = 1f;
			}
			float factor = i / (float)SmoothedOldPos.Count * mulFac;
			float widthZ = TrailWidthFunction(factor);
			var c0 = new Color(1 - (normalDir.X + 25f) / 50f, 1 - (normalDir.Y + 25f) / 50f, 0.1f * WarpStrength, 1);
			float x0 = factor * 1.3f + (float)(Main.time * 0.03f);
			Vector2 drawPos = SmoothedOldPos[i] - Main.screenPosition + halfSize;
			bars.Add(drawPos + new Vector2(0, 1).RotatedBy(MathHelper.TwoPi * 0f / 3f) * width, c0, new Vector3(x0, 1, widthZ));
			bars.Add(drawPos, c0, new Vector3(x0, 0.5f, widthZ));
			bars2.Add(drawPos + new Vector2(0, 1).RotatedBy(MathHelper.TwoPi * 1f / 3f) * width, c0, new Vector3(x0, 1, widthZ));
			bars2.Add(drawPos, c0, new Vector3(x0, 0.5f, widthZ));
			bars3.Add(drawPos + new Vector2(0, 1).RotatedBy(MathHelper.TwoPi * 2f / 3f) * width, c0, new Vector3(x0, 1, widthZ));
			bars3.Add(drawPos, c0, new Vector3(x0, 0.5f, widthZ));
		}
		if (bars.Count >= 2 && bars.Count >= 2 && bars.Count >= 3)
		{
			spriteBatch.Draw(TrailTexture, bars, PrimitiveType.TriangleStrip);
			spriteBatch.Draw(TrailTexture, bars2, PrimitiveType.TriangleStrip);
			spriteBatch.Draw(TrailTexture, bars3, PrimitiveType.TriangleStrip);
		}
	}
}